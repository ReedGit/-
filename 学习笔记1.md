#学习笔记一
---
##类
1. 在类中，成员变量和局部变量重名时，局部变量具有更高优先级，方法内部优先使用局部变量的值。
2. java会给成员变量一个初始值，但不会给局部变量赋予初始值，所以定义局部变量时要对变量初始化。
3. 当没有指定构造方法时，系统会自动添加无参的构造方法；当有指定的构造方法时，无论是有参、无参的构造方法，系统都不会自动添加无参的构造方法。


##static
1. 修饰成员变量时，既可以通过类名直接访问，也可以通过对象名访问，无论通过哪种方式修改或者访问，一旦静态成员变量值发生改变，所有使用了该成员变量地方的值都发生改变。
2. ###静态成员方法
	1. 修饰成员方法时，静态方法中可以直接调用同类中的静态成员，但不能直接调用非静态成员，如：![](http://img.mukewang.com/5392d6eb0001283007020239.jpg)如果希望在静态方法中调用非静态变量，可以通过创建类的对象，然后通过对象俩访问非静态变量，如：![](http://img.mukewang.com/5392d7390001a10806150193.jpg)
	2. 在普通成员方法中，则可以直接访问同类的非静态变量和静态变量
	3. 静态方法中不能直接调用非静态方法，需要通过对象来访问非静态方法，参考第1点。
3. 程序运行时静态初始化块最先被执行，然后执行普通初始化块，最后才执行构造方法


##内部类
1. 外部类不能直接使用内部类的成员和方法，需要通过内部类的对象来访问其成员变量，即[外部类.new 内部类()]。
2. ###内部类
	1. 如果外部类和成员内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，可以使用 this 关键字。如：![](http://img.mukewang.com/539e638b0001ab1208200295.jpg)
	2. ####静态内部类
		1. 创建静态内部类的对象时，不需要外部类的对象，可以直接创建**内部类 对象名 = new 内部类()**
		2. 如果外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过“成员名”直接调用外部类的静态成员
		3. 静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问
	3. 由于方法内部类不能在外部类的方法以外的地方使用，因此方法内部类不能使用访问控制符和 static 修饰符。


##继承
1. 先初始化父类再初始化子类
2. 类中，先执行初始化对象中的属性，再执行构造方法中的初始化


##final
final可以修饰类、方法、属性和变量。final修饰类，则该类不允许被继承；final修饰方法，则该方法不允许被覆盖（重写）；final修饰属性，则该类的属性不会进行隐式的初始化（即类的初始化属性必须有值）或在构造方法中赋值（但只能选其一）；final修饰变量，则该变量的值只能赋值一次，即为常量。


##super
在对象的内部使用，可以代表父类对象，访问父类属性，即super.属性，访问父类方法，即super.方法()。
##Object类(所有类均是该类子类)
Object.equals()比较的是对象的引用是否指向同一块内存地址。(注："=="如果判断的不是基本数据类型，而是引用类型是否相同，比较的是地址)

当需要判断两个类是否相同时应重写equals()方法（注：可以利用编译自动生成）


##多态
1. 引用多态：父类的引用可以指向子类的对象，即：**父类 对象 = new 子类()**，但子类引用不能指向父类对象。
2. 方法多态：父类引用创建子类对象时（即第1点），调用的方法为子类重写的方法或者继承的方法，不能调用子类特有的方法。


##引用类型转换
1. 向上类型转换（隐式/自动类型转换），是小类型到大类型的转换
2. 向下类型转换（强制类型转换），是大类型到小类型的转换
3. instanceof运算符，来解决引用对象的类型，避免类型转换的安全性问题，例如a instanceof B 用于判断对象a是否能够转换成B（类）的类型


##抽象类


###应用场景：
1. 在某些情况下，某个父类只是知道其子类应该包含怎样的方法，但无法准确知道这些子类如何实现这些方法。
2. 从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为子类的模板，从而避免了子类设计的随意性。 


###作用：
限制规定子类必须实现某些方法，但不关注实现细节。


###使用规则：
1. abstract定义抽象类。
2. abstract定义抽象方法，只有声明，不需要实现。
3. 包含抽象方法的类是抽象类。
4. 抽象类中可以包含普通的方法，也可以没有抽象方法。
5. 抽象类不能直接创建，可以定义引用变量。


##接口
1. 概念：接口可以理解为一种特殊的类，由全局变量和公共的抽象方法所组成。
2. 接口可以继承多个接口。
3. [修饰符][abstract]interface 接口名 [extends 父接口1,父接口2,...]（注：abstract如果没有手动添加，系统会自动添加）
4. 接口的定义：
	1. 常量：接口中的属性是常量，即使定义时不添加public static final修饰符，系统也会自动加上。
	2. 方法：接口中的方法只能是抽象方法，总是使用，即使定义时比添加public abstract修饰符，系统也会自动加上。
5. 继承父类必须要在实现接口之前：[修饰符] class 类名 extends 父类 implements 接口1,接口2,...
6. 以内名内部类的方式实现接口
	
	语法格式：
		
		public interface Interface{
			public void method();
		}
		Interface i = new Interface(){
			public void method(){
				System.out.println("匿名内部类实现接口的方式");
			}
		};
		i.method();
		或者
		new Interface(){
			public void method(){
				...
			}
		}.method();